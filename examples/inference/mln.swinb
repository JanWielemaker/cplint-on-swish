<div class="notebook">
<div class="nb-cell html math">
<h2>Markov Logic Networks</h2>

Markov Networks (MN) and Markov Logic Networks (MLN) can be encoded with 
Probabilistic Logic Programming. The encoding is based on the observation that
a MN factor can be represented with a Bayesian Newtork (BN) with an extra node that
is always observed.
For example, the MLN clause
<pre><code>1.5  Intelligent(x) => GoodMarks(x) 
</code></pre>
for a single constant <code>anna</code> originates an edge betwenn the Boolean nodes  
for  <code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code>. This means that the two variables
cannot be d-separated in any way. This dependence can be modelend with BNs by
adding an extra Boolean node, <code>Factor(anna)</code>, that is a child of 
 <code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code> and is observed. In this way,
 <code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code> are not d-separated in the BN no 
matter what other nodes the BN contains.

The problem is now how to assign values to the conditional probability table
(CPT) of
<code>Factor(anna)</code> so that the joint distribution of 
<code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code> in the BN
is the same as that of the MN. The MLN clause above contributes
to the probabilities of the worlds with a factor
\(e^{1.5}\)
 for the worlds where the
clause is true and 1 for the worlds where the clause is false.

In the BN, the probability of a world would be represented by 
\(P(i,g|f)\) where \(i\) and \(g\) are values for
<code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code> and \(f\) is <co
de>Factor(anna)</code>\(=true\).  \(P(i,g|f)\) is given by
\[
P(i,g|f)=\frac{P(i,g,f)}{P(f)}=\frac{P(i,g)P(f|i,g)}{\sum_{i',g'}P(i',g')P(f|i',g')}
\]
so each world \((i,g)\) gets multiplied by the factor \(P(f|i,g)\)
We can multiply all the factor values by a constant and get the same result,
as the constant will be 
simplified between the numrator and the denominator.
For example, we can divide 
the values for the sum over the worlds of the factor values:
there are four worlds, in three the factor is true and in one it is false,
so we divide for \(3e^{1.5}+1\). This ensures that all factor values are
between 0 and 1 and can be used as probability values
in the CPT: \(e^{1.5}/(3e^{1.5}+1)\) is the probability of <code>Factor(anna)</code> being
true given that the parents' values make the clause true and \(1/(3e^{1.5}+1)\) is the
probability of  <code>Factor(anna)</code> being
true given that the parents' values make the clause false.
In this way in fact \(P(f|i,g)\) where \(i\) and \(g\) are values for 
<code>Intelligent(anna)</code> and <code>GoodMarks(anna)</code> and \(f\) is <code>Factor(anna)</code>\(=true\) is given
by
\[
P(i,g|f)=\frac{P(i,g,f)}{P(f)}=\frac{P(i)P(g)P(f|i,g)}{\sum_{i',g'}P(i')P(g')P(f|i',g')}
\]
If we assign 0.5 to \(P(i)\) and \(P(f)\) we get
\[
P(i,g|f)=\frac{0.25P(f|i,g)}{0.25\sum_{i',g'}P(f|i',g')}=
\frac{P(f|i,g)}{\sum_{i',g'}P(f|i',g')}
=\frac{1}{3e^{1.5}+1}
\]
if \(i=true\) and \(g=\mathit{false}\) and
\[
=\frac{e^{1.5}}{3e^{1.5}+1}
\]
otherwise.

Alternatively, we can multiply all factor values for \(e^{-1.5}\). In this way
the worlds where the clause is true get a \(1\) factor and the other worlds get
a \(e^{-1.5}\). These factor values are between \(0\) and \(1\) and so can be 
used as probabilities in the CPT. If the weight \(\alpha\) of the clause is 
negative, then the factor \(e^\alpha\) will appear in the weight of worlds where 
the clause is true and 1 in the weight of the other worlds
and these values can be used directly in the CPT.
  <script type="text/javascript">
var cell=notebook.$(".math");
var fileref=document.createElement('script');
        fileref.setAttribute("type","text/javascript");
        fileref.setAttribute("src", "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML");
 cell.appendChild(fileref);
</script>

</div>
<div class="nb-cell query">
prob(heads(coin),Prob). 
</div>
<div class="nb-cell markdown">
## Code

Preamble:
</div>
<div class="nb-cell program prolog" data-background="true">
:- use_module(library(pita)).

:- pita.

:- begin_lpad.
</div>
<div class="nb-cell html">
The MLN formula
<pre><code>1.5  Intelligent(x) => GoodMarks(x) 
</code></pre>
is translated into the four clauses
</div>
<div class="nb-cell program prolog" data-background="true">

factor1(X): 0.31025740516:- \+intelligent(X).
factor1(X): 0.0692277845:- intelligent(X), \+good_marks(X).
factor1(X): 0.31025740516:- intelligent(X), good_marks(X).
</div>
<div class="nb-cell html">
where \(0.3102574051=e^{1.5}/(3e^{-1.5}+1)\) and \(0.0692277845=1/(3e^{-1.5}+1)\).

The MLN formula
<pre><code>
1.1 Friends(x, y) => (Intelligent(x) <=> Intelligent(y)) 
</code></pre>
is translated into the four clauses
</div>
<div class="nb-cell program prolog" data-background="true">
factor2(X,Y): 0.150020804:- \+friends(X,Y).
factor2(X,Y): 0.150020804:- friends(X,Y), intelligent(X),intelligent(Y).
factor2(X,Y): 0.150020804:- friends(X,Y), \+intelligent(X),\+intelligent(Y).
factor2(X,Y): 0.049937588:- friends(X,Y), intelligent(X),\+intelligent(Y).
factor2(X,Y): 0.049937588:- friends(X,Y), \+intelligent(X),intelligent(Y).

student(anna).
student(bob).
intelligent(_):0.5.

good_marks(_):0.5.

friends(_,_):0.5.

%evidence:- factor1(anna),factor1(bob),factor2(anna,anna),
    factor2(anna,bob),factor2(bob,anna),factor2(bob,bob).

ev_intelligent_bob_friends_anna_bob:-
    intelligent(bob),friends(anna,bob),evidence.

:- end_lpad.

/** <examples>

?- prob(intelligent(anna),P).
?- prob(intelligent(anna),ev_intelligent_bob_friends_anna_bob,P).

*/
</div>
</div>
